{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EKG WIKI HOME Welcome to the EKG wiki! UI Widget Abstract Button Checkbox Listbox Services & Features Layout Input Handler Allocator GPU Tools Core IO Events Task Utility Item","title":"EKG WIKI HOME"},{"location":"#ekg-wiki-home","text":"Welcome to the EKG wiki!","title":"EKG WIKI HOME"},{"location":"#ui","text":"Widget Abstract Button Checkbox Listbox","title":"UI"},{"location":"#services-features","text":"Layout Input Handler Allocator GPU Tools","title":"Services &amp; Features"},{"location":"#core","text":"IO Events Task","title":"Core"},{"location":"#utility","text":"Item","title":"Utility"},{"location":"abstract/","text":"Overview Fundamentals Methods Fundamentals The abstract widget is not used for the user-programmer part and is not recommended for any purpose. Abstract widget is used by the runtime core as a polymorphism heritage base for handling everything. Methods Abstract Set tag (reserved purposes). ekg::ui::abstract *set_tag(std::string_view tag); Get the tag (reserved purposes). std::string_view get_tag(); Set the widget ID, see details here . ekg::ui::abstract *set_id(int32_t id); Get the widget ID, see details here . int32_t get_id(); Set parent mother widget ID, see details here . ekg::ui::abstract *set_parent_id(int32_t parent_id); Get parent mother widget ID, see details here . int32_t get_parent_id(); Add a child to the widget , see details here . ekg::ui::abstract *add_child(int32_t id); Get the widget child id list, see details here . std::vector<int32_t> &get_child_id_list(); Remove a child widget from the mother widget , see details here . ekg::ui::abstract *remove_child(int32_t id); Check if the widget has a parent mother widget , see details here . bool has_parent(); Check if the widget has children, see details here . bool has_children(); Set widget alive state. ekg::ui::abstract *set_alive(bool state); Get widget alive state. bool is_alive(); Destroy the widget . void destroy(); Set the widget state . ekg::ui::abstract *set_state(const ekg::state &_state); Get the widget state . ekg::state get_state(); Set the widget type . ekg::ui::abstract *set_type(const ekg::type &_type); Get the widget type . ekg::type get_type(); Set the widget level . ekg::ui::abstract *set_level(const ekg::type &_level); Get the widget level . ekg::type get_level(); Get layout dock position. uint16_t get_place_dock(); Get the sync flags reference. uint16_t &get_sync(); Reset the UI data front-end with the widget back-end. void reset(); Access to absolute widget back-end rectangle. ekg::rect &widget(); Get the UI data front-end rectangle. ekg::rect &ui();","title":"Abstract"},{"location":"abstract/#overview","text":"Fundamentals Methods","title":"Overview"},{"location":"abstract/#fundamentals","text":"The abstract widget is not used for the user-programmer part and is not recommended for any purpose. Abstract widget is used by the runtime core as a polymorphism heritage base for handling everything.","title":"Fundamentals"},{"location":"abstract/#methods","text":"","title":"Methods"},{"location":"abstract/#abstract","text":"Set tag (reserved purposes). ekg::ui::abstract *set_tag(std::string_view tag); Get the tag (reserved purposes). std::string_view get_tag(); Set the widget ID, see details here . ekg::ui::abstract *set_id(int32_t id); Get the widget ID, see details here . int32_t get_id(); Set parent mother widget ID, see details here . ekg::ui::abstract *set_parent_id(int32_t parent_id); Get parent mother widget ID, see details here . int32_t get_parent_id(); Add a child to the widget , see details here . ekg::ui::abstract *add_child(int32_t id); Get the widget child id list, see details here . std::vector<int32_t> &get_child_id_list(); Remove a child widget from the mother widget , see details here . ekg::ui::abstract *remove_child(int32_t id); Check if the widget has a parent mother widget , see details here . bool has_parent(); Check if the widget has children, see details here . bool has_children(); Set widget alive state. ekg::ui::abstract *set_alive(bool state); Get widget alive state. bool is_alive(); Destroy the widget . void destroy(); Set the widget state . ekg::ui::abstract *set_state(const ekg::state &_state); Get the widget state . ekg::state get_state(); Set the widget type . ekg::ui::abstract *set_type(const ekg::type &_type); Get the widget type . ekg::type get_type(); Set the widget level . ekg::ui::abstract *set_level(const ekg::type &_level); Get the widget level . ekg::type get_level(); Get layout dock position. uint16_t get_place_dock(); Get the sync flags reference. uint16_t &get_sync(); Reset the UI data front-end with the widget back-end. void reset(); Access to absolute widget back-end rectangle. ekg::rect &widget(); Get the UI data front-end rectangle. ekg::rect &ui();","title":"Abstract"},{"location":"button/","text":"Overview Fundamentals Examples Methods Fundamentals The button widget works fundamentally simply, you have a text, and the alignment of text. Each button has it is own optional ekg::cpu::event callback event task , where one lambda function is optional. The button widget contains two string sets set_text and set_tag , set_tag is reserved for user purposes, while set_text is the visible text of the widget button . Examples For creating a simple button with no callback event. auto p_button = ekg::button(\"cat\", ekg::dock::fill | ekg::next); The first parameter is the visible text of a button . The second parameter is the docking alignment in the frame widget. To create a callback button, with task . p_button->set_callback(new ekg::cpu::event(\"cat\", nullptr, [](void *p_callback) { ekg::log() << \"Cat!\"; })); This callback event is not deleted after execution, because it is batched, which means that all clicks will execute this task . Methods Button Set the font-size of button text. ekg::ui::button *set_font_size(ekg::font font); Get the font-size of button text. ekg::font get_font_size(); Set layout dock position. ekg::ui::button *set_place(uint16_t dock); Set dimension width in pixels, see details here . ekg::ui::button *set_width(float w); Get dimension width in pixels, see details here . float get_width(); Set dimension height in scale factor, see details here . ekg::ui::button *set_scaled_height(int32_t h); Get dimension height in scale factor, see details here . int32_t get_scaled_height(); Get dimension height in pixels. float get_height(); Set callback event task . ekg::ui::button *set_callback(ekg::cpu::event *p_callback); Get callback event task . ekg::cpu::event *get_callback(); Set display text. ekg::ui::button *set_text(std::string_view text); Get display text. std::string_view get_text(); Set button state pressed/callback. ekg::ui::button *set_value(bool state); Get button state. bool get_value(); Set text alignment dock . ekg::ui::button *set_text_align(uint16_t dock); Get text alignment dock . uint16_t get_text_align(); Abstract Set tag (reserved purposes). ekg::ui::abstract *set_tag(std::string_view tag); Get the tag (reserved purposes). std::string_view get_tag(); Set the widget ID, see details here . ekg::ui::abstract *set_id(int32_t id); Get the widget ID, see details here . int32_t get_id(); Set parent mother widget ID, see details here . ekg::ui::abstract *set_parent_id(int32_t parent_id); Get parent mother widget ID, see details here . int32_t get_parent_id(); Add a child to the widget , see details here . ekg::ui::abstract *add_child(int32_t id); Get the widget child id list, see details here . std::vector<int32_t> &get_child_id_list(); Remove a child widget from the mother widget , see details here . ekg::ui::abstract *remove_child(int32_t id); Check if the widget has a parent mother widget , see details here . bool has_parent(); Check if the widget has children, see details here . bool has_children(); Set widget alive state. ekg::ui::abstract *set_alive(bool state); Get widget alive state. bool is_alive(); Destroy the widget . void destroy(); Set the widget state . ekg::ui::abstract *set_state(const ekg::state &_state); Get the widget state . ekg::state get_state(); Set the widget type . ekg::ui::abstract *set_type(const ekg::type &_type); Get the widget type . ekg::type get_type(); Set the widget level . ekg::ui::abstract *set_level(const ekg::type &_level); Get the widget level . ekg::type get_level(); Get layout dock position. uint16_t get_place_dock(); Get the sync flags reference. uint16_t &get_sync(); Reset the UI data front-end with the widget back-end. void reset(); Access to absolute widget back-end rectangle. ekg::rect &widget(); Get the UI data front-end rectangle. ekg::rect &ui();","title":"Button"},{"location":"button/#overview","text":"Fundamentals Examples Methods","title":"Overview"},{"location":"button/#fundamentals","text":"The button widget works fundamentally simply, you have a text, and the alignment of text. Each button has it is own optional ekg::cpu::event callback event task , where one lambda function is optional. The button widget contains two string sets set_text and set_tag , set_tag is reserved for user purposes, while set_text is the visible text of the widget button .","title":"Fundamentals"},{"location":"button/#examples","text":"For creating a simple button with no callback event. auto p_button = ekg::button(\"cat\", ekg::dock::fill | ekg::next); The first parameter is the visible text of a button . The second parameter is the docking alignment in the frame widget. To create a callback button, with task . p_button->set_callback(new ekg::cpu::event(\"cat\", nullptr, [](void *p_callback) { ekg::log() << \"Cat!\"; })); This callback event is not deleted after execution, because it is batched, which means that all clicks will execute this task .","title":"Examples"},{"location":"button/#methods","text":"","title":"Methods"},{"location":"button/#button","text":"Set the font-size of button text. ekg::ui::button *set_font_size(ekg::font font); Get the font-size of button text. ekg::font get_font_size(); Set layout dock position. ekg::ui::button *set_place(uint16_t dock); Set dimension width in pixels, see details here . ekg::ui::button *set_width(float w); Get dimension width in pixels, see details here . float get_width(); Set dimension height in scale factor, see details here . ekg::ui::button *set_scaled_height(int32_t h); Get dimension height in scale factor, see details here . int32_t get_scaled_height(); Get dimension height in pixels. float get_height(); Set callback event task . ekg::ui::button *set_callback(ekg::cpu::event *p_callback); Get callback event task . ekg::cpu::event *get_callback(); Set display text. ekg::ui::button *set_text(std::string_view text); Get display text. std::string_view get_text(); Set button state pressed/callback. ekg::ui::button *set_value(bool state); Get button state. bool get_value(); Set text alignment dock . ekg::ui::button *set_text_align(uint16_t dock); Get text alignment dock . uint16_t get_text_align();","title":"Button"},{"location":"button/#abstract","text":"Set tag (reserved purposes). ekg::ui::abstract *set_tag(std::string_view tag); Get the tag (reserved purposes). std::string_view get_tag(); Set the widget ID, see details here . ekg::ui::abstract *set_id(int32_t id); Get the widget ID, see details here . int32_t get_id(); Set parent mother widget ID, see details here . ekg::ui::abstract *set_parent_id(int32_t parent_id); Get parent mother widget ID, see details here . int32_t get_parent_id(); Add a child to the widget , see details here . ekg::ui::abstract *add_child(int32_t id); Get the widget child id list, see details here . std::vector<int32_t> &get_child_id_list(); Remove a child widget from the mother widget , see details here . ekg::ui::abstract *remove_child(int32_t id); Check if the widget has a parent mother widget , see details here . bool has_parent(); Check if the widget has children, see details here . bool has_children(); Set widget alive state. ekg::ui::abstract *set_alive(bool state); Get widget alive state. bool is_alive(); Destroy the widget . void destroy(); Set the widget state . ekg::ui::abstract *set_state(const ekg::state &_state); Get the widget state . ekg::state get_state(); Set the widget type . ekg::ui::abstract *set_type(const ekg::type &_type); Get the widget type . ekg::type get_type(); Set the widget level . ekg::ui::abstract *set_level(const ekg::type &_level); Get the widget level . ekg::type get_level(); Get layout dock position. uint16_t get_place_dock(); Get the sync flags reference. uint16_t &get_sync(); Reset the UI data front-end with the widget back-end. void reset(); Access to absolute widget back-end rectangle. ekg::rect &widget(); Get the UI data front-end rectangle. ekg::rect &ui();","title":"Abstract"},{"location":"checkbox/","text":"Overview Fundamentals Examples Methods Fundamentals","title":"Checkbox"},{"location":"checkbox/#overview","text":"Fundamentals Examples Methods","title":"Overview"},{"location":"checkbox/#fundamentals","text":"","title":"Fundamentals"},{"location":"create-a-gui/","text":"","title":"Create a gui"},{"location":"handler-service/","text":"Overview Runtime Task Runtime The event system and handler service exist for two different purposes, the handler is a task manager that works with callback events (tasks) and executes the main tasks of the EKG runtime core. The event system exists to release UI events. Task The structure of a task is simple. ekg::cpu::event task { .p_tag = \"task event cat 1\", .p_callback = nullptr, .function = [](void *p_callback) {}; }; For dispatching a task is simple, reference or copy ekg::core->service_handler.generate() auto &task = ekg::core->service_handler.generate(); task.p_tag = \"cat\"; task.p_callback = nullptr; task.function = [](void *p_callback) {}; // It is already dispatched :)!","title":"Overview"},{"location":"handler-service/#overview","text":"Runtime Task","title":"Overview"},{"location":"handler-service/#runtime","text":"The event system and handler service exist for two different purposes, the handler is a task manager that works with callback events (tasks) and executes the main tasks of the EKG runtime core. The event system exists to release UI events.","title":"Runtime"},{"location":"handler-service/#task","text":"The structure of a task is simple. ekg::cpu::event task { .p_tag = \"task event cat 1\", .p_callback = nullptr, .function = [](void *p_callback) {}; }; For dispatching a task is simple, reference or copy ekg::core->service_handler.generate() auto &task = ekg::core->service_handler.generate(); task.p_tag = \"cat\"; task.p_callback = nullptr; task.function = [](void *p_callback) {}; // It is already dispatched :)!","title":"Task"},{"location":"installation/","text":"Overview Download EKG Toolchains Support Include, and Linker Download EKG contains many releases,","title":"Installation"},{"location":"installation/#overview","text":"Download EKG Toolchains Support Include, and Linker","title":"Overview"},{"location":"installation/#download","text":"EKG contains many releases,","title":"Download"},{"location":"item/","text":"Item The EKG library contains an item collector named ekg::item , the item is a recursive vector collection. Examples The item contains the following fields: value display-text/tag of item. attr the attribute flag defines the rendering, and processing behavior. child_list child list to other items. component geometry data of item component. Setting a value to an item is simple: ekg::item item(\"animals\"); // constructor explicit ekg::item item {\"animals\"}; // initialization-list implicit ekg::item item = {\"animals\"}; // assign initialization-list implicit ekg::item item {}; // initialization-list implicit item.value = \"animals\"; // accessing the field, but is not too recommendedd Item contains attr (attributes) flags and state flags, both manually configurable or automatically by setting the value component with special chars. Special chars: \\t add automatically the attribute ekg::attr::separator . \\\\ add automatically the attribute ekg::attr::box . \\1 add automatically the attribute ekg::attr::category . \\2 add automatically the attribute ekg::attr::row . \\3 add automatically the attribute ekg::attr::row_member . \\4 add automatically the attribute ekg::attr::unselectable . ekg::item item {\"Animals\"}; item.set_value(\"\\t\\\\Select All\"); // insert a std::vector<std::string> to item. item.insert({\"\\\\Dogs\"}); item.insert({\"\\\\Cats\"}); item.insert({\"\\\\Humans\"}); You can iterate over the item children using for loop: ekg::item item(\"animals\"); item.insert({\"dogs\", \"cats\", \"humans\"}); for (ekg::item &items : item) { std::cout << items.value << std::endl; } Methods Set value with attributes check, use this instead of setting directly the field. void set_value(std::string_view _value); Initialize an item child without generating a copy. ekg::item &emplace_back(); Insert an item copy in the child list. void push_back(const ekg::item &item); Insert an item by setting the value. void push_back(std::string_view item_value); Insert a std::vector<ekg::item> child list. void insert(const std::vector<std::string> &item_value_list); Get the child item by index position. ekg::item &at(uint64_t index); Check if has item children. bool empty() const; Get the size of the child list. uint64_t size() const; Get begin iterator point. std::vector<ekg::item>::iterator begin(); Get end iterator point. std::vector<ekg::item>::iterator end(); Get const begin iterator point. std::vector<ekg::item>::const_iterator cbegin() const; Get const end iterator point. std::vector<ekg::item>::const_iterator cend() const;","title":"Item"},{"location":"item/#item","text":"The EKG library contains an item collector named ekg::item , the item is a recursive vector collection.","title":"Item"},{"location":"item/#examples","text":"The item contains the following fields: value display-text/tag of item. attr the attribute flag defines the rendering, and processing behavior. child_list child list to other items. component geometry data of item component. Setting a value to an item is simple: ekg::item item(\"animals\"); // constructor explicit ekg::item item {\"animals\"}; // initialization-list implicit ekg::item item = {\"animals\"}; // assign initialization-list implicit ekg::item item {}; // initialization-list implicit item.value = \"animals\"; // accessing the field, but is not too recommendedd Item contains attr (attributes) flags and state flags, both manually configurable or automatically by setting the value component with special chars. Special chars: \\t add automatically the attribute ekg::attr::separator . \\\\ add automatically the attribute ekg::attr::box . \\1 add automatically the attribute ekg::attr::category . \\2 add automatically the attribute ekg::attr::row . \\3 add automatically the attribute ekg::attr::row_member . \\4 add automatically the attribute ekg::attr::unselectable . ekg::item item {\"Animals\"}; item.set_value(\"\\t\\\\Select All\"); // insert a std::vector<std::string> to item. item.insert({\"\\\\Dogs\"}); item.insert({\"\\\\Cats\"}); item.insert({\"\\\\Humans\"}); You can iterate over the item children using for loop: ekg::item item(\"animals\"); item.insert({\"dogs\", \"cats\", \"humans\"}); for (ekg::item &items : item) { std::cout << items.value << std::endl; }","title":"Examples"},{"location":"item/#methods","text":"Set value with attributes check, use this instead of setting directly the field. void set_value(std::string_view _value); Initialize an item child without generating a copy. ekg::item &emplace_back(); Insert an item copy in the child list. void push_back(const ekg::item &item); Insert an item by setting the value. void push_back(std::string_view item_value); Insert a std::vector<ekg::item> child list. void insert(const std::vector<std::string> &item_value_list); Get the child item by index position. ekg::item &at(uint64_t index); Check if has item children. bool empty() const; Get the size of the child list. uint64_t size() const; Get begin iterator point. std::vector<ekg::item>::iterator begin(); Get end iterator point. std::vector<ekg::item>::iterator end(); Get const begin iterator point. std::vector<ekg::item>::const_iterator cbegin() const; Get const end iterator point. std::vector<ekg::item>::const_iterator cend() const;","title":"Methods"},{"location":"layout/","text":"Overview Here you will read these main topics: Fundamentals Docking Widgets Fundamentals The layout mask or docking system, is an internal feature of the layout service, A layout mask is a mask of positions between rectangles of a widget. The purpose of having a layout mask is to make flexible widgets. Docking The acceptable docking positions are: center, left, right, top, bottom Each docking direction has it is own behavior. Widgets All widgets use the layout mask feature, normally you can set set_*_align . e.g. button widget align method: p_button->set_text_align(ekg::dock::center);","title":"Overview"},{"location":"layout/#overview","text":"Here you will read these main topics: Fundamentals Docking Widgets","title":"Overview"},{"location":"layout/#fundamentals","text":"The layout mask or docking system, is an internal feature of the layout service, A layout mask is a mask of positions between rectangles of a widget. The purpose of having a layout mask is to make flexible widgets.","title":"Fundamentals"},{"location":"layout/#docking","text":"The acceptable docking positions are: center, left, right, top, bottom Each docking direction has it is own behavior.","title":"Docking"},{"location":"layout/#widgets","text":"All widgets use the layout mask feature, normally you can set set_*_align . e.g. button widget align method: p_button->set_text_align(ekg::dock::center);","title":"Widgets"},{"location":"listbox/","text":"# Overview Fundamentals Methods Container Fundamentals The listbox widget displays text fields as a 2D list. Item stores each text field, representing a geometry component. The first items represent the category column, and the sub- items from the category represent the rows. ekg::item &item = p_listbox->item(); item.insert(\"Cats\"); // category: Cats item.insert(\"Dogs\"); // category: Dogs item.insert(\"Plants\"); // category: Plants item.at(0).insert(\"Potato\"); item.at(1).insert(\"Toto\"); item.at(2).insert(\"Flower\"); Each container category is independent of the others, however, EKG listbox contains one mode to link all items , named, single column mode. ekg::item &item = p_listbox->item(); item.insert(\"Name\"); // category: Name item.insert(\"Description\"); // category: Description item.insert(\"Status\"); // category: Status p_listbox->set_single_column_mode(true); item.at(0).insert(\"Potato\"); item.at(1).insert(\"Cat\"); item.at(2).insert(\"Playing with kitty-friends!\"); item.at(0).insert(\"Chiquinha\"); item.at(1).insert(\"Cat\"); item.at(2).insert(\"Carrying of children kitties!\"); The single-column mode can also reserve empty spaces, to prevent issues in processing, but it is possible to perform a filling. item.fill(0, ekg::attr::box | ekg::attr::unselectable); // edit attributes item.fill(0, \"Name\"); // edit name Methods Listbox Set single-column mode state. ekg::ui::listbox *set_single_column_mode(bool state); Get single-column mode state. bool is_single_column_mode(); Set dimension width in pixels, see details here . ekg::ui::listbox *set_width(float w); Get dimension width in pixels, see details here . float get_width(); Set dimension height in factor-height, see details here . ekg::ui::listbox *set_scaled_height(int32_t factor); Get dimension height in factor-height, see details here . int32_t get_scaled_height(); Get dimension height in pixels, see details here . float get_height(); Set layout dock position. ekg::ui::listbox *set_place(uint16_t dock); Get the item data. ekg::item &item(); Set the category font used. ekg::ui::listbox *set_category_font_size(ekg::font font); Get the category font used. ekg::font get_category_font_size(); Set the item font used. ekg::ui::listbox *set_item_font_size(ekg::font font); Get the item font used. ekg::font get_item_font_size(); Abstract Set tag (reserved purposes). ekg::ui::abstract *set_tag(std::string_view tag); Get the tag (reserved purposes). std::string_view get_tag(); Set the widget ID, see details here . ekg::ui::abstract *set_id(int32_t id); Get the widget ID, see details here . int32_t get_id(); Set parent mother widget ID, see details here . ekg::ui::abstract *set_parent_id(int32_t parent_id); Get parent mother widget ID, see details here . int32_t get_parent_id(); Add a child to the widget , see details here . ekg::ui::abstract *add_child(int32_t id); Get the widget child id list, see details here . std::vector<int32_t> &get_child_id_list(); Remove a child widget from the mother widget , see details here . ekg::ui::abstract *remove_child(int32_t id); Check if the widget has a parent mother widget , see details here . bool has_parent(); Check if the widget has children, see details here . bool has_children(); Set widget alive state. ekg::ui::abstract *set_alive(bool state); Get widget alive state. bool is_alive(); Destroy the widget . void destroy(); Set the widget state . ekg::ui::abstract *set_state(const ekg::state &_state); Get the widget state . ekg::state get_state(); Set the widget type . ekg::ui::abstract *set_type(const ekg::type &_type); Get the widget type . ekg::type get_type(); Set the widget level . ekg::ui::abstract *set_level(const ekg::type &_level); Get the widget level . ekg::type get_level(); Get layout dock position. uint16_t get_place_dock(); Get the sync flags reference. uint16_t &get_sync(); Reset the UI data front-end with the widget back-end. void reset(); Access to absolute widget back-end rectangle. ekg::rect &widget(); Get the UI data front-end rectangle. ekg::rect &ui(); Container Each row is a component container, a listbox container allocates all Items cursively opened and dynamically calculates the visible index, based on the opened components count. When opening an item component, the container increases the open counter, and when an item component is closed, it decreases the open counter. This simple arithmetic system is useful for estimating container height. The rendering optimization is possible with a unique height, and by default, it is font normal size. Calculating a dynamically visible index requires normalizing the scroll value with the estimated height. scroll means the scrolling value, len is the container components' length, and height is the container's estimated height. The dynamic index calculation inverts the signal of the scroll because the scroll vector must subtract the position of the rectangle, and for the formula, it is not required, since we want to get normalized. All closed components are skipped in the rendering section, the item component contains the count of total children, and it is used to increase the current index iteration.","title":"Listbox"},{"location":"listbox/#overview","text":"Fundamentals Methods Container","title":"# Overview"},{"location":"listbox/#fundamentals","text":"The listbox widget displays text fields as a 2D list. Item stores each text field, representing a geometry component. The first items represent the category column, and the sub- items from the category represent the rows. ekg::item &item = p_listbox->item(); item.insert(\"Cats\"); // category: Cats item.insert(\"Dogs\"); // category: Dogs item.insert(\"Plants\"); // category: Plants item.at(0).insert(\"Potato\"); item.at(1).insert(\"Toto\"); item.at(2).insert(\"Flower\"); Each container category is independent of the others, however, EKG listbox contains one mode to link all items , named, single column mode. ekg::item &item = p_listbox->item(); item.insert(\"Name\"); // category: Name item.insert(\"Description\"); // category: Description item.insert(\"Status\"); // category: Status p_listbox->set_single_column_mode(true); item.at(0).insert(\"Potato\"); item.at(1).insert(\"Cat\"); item.at(2).insert(\"Playing with kitty-friends!\"); item.at(0).insert(\"Chiquinha\"); item.at(1).insert(\"Cat\"); item.at(2).insert(\"Carrying of children kitties!\"); The single-column mode can also reserve empty spaces, to prevent issues in processing, but it is possible to perform a filling. item.fill(0, ekg::attr::box | ekg::attr::unselectable); // edit attributes item.fill(0, \"Name\"); // edit name","title":"Fundamentals"},{"location":"listbox/#methods","text":"","title":"Methods"},{"location":"listbox/#listbox","text":"Set single-column mode state. ekg::ui::listbox *set_single_column_mode(bool state); Get single-column mode state. bool is_single_column_mode(); Set dimension width in pixels, see details here . ekg::ui::listbox *set_width(float w); Get dimension width in pixels, see details here . float get_width(); Set dimension height in factor-height, see details here . ekg::ui::listbox *set_scaled_height(int32_t factor); Get dimension height in factor-height, see details here . int32_t get_scaled_height(); Get dimension height in pixels, see details here . float get_height(); Set layout dock position. ekg::ui::listbox *set_place(uint16_t dock); Get the item data. ekg::item &item(); Set the category font used. ekg::ui::listbox *set_category_font_size(ekg::font font); Get the category font used. ekg::font get_category_font_size(); Set the item font used. ekg::ui::listbox *set_item_font_size(ekg::font font); Get the item font used. ekg::font get_item_font_size();","title":"Listbox"},{"location":"listbox/#abstract","text":"Set tag (reserved purposes). ekg::ui::abstract *set_tag(std::string_view tag); Get the tag (reserved purposes). std::string_view get_tag(); Set the widget ID, see details here . ekg::ui::abstract *set_id(int32_t id); Get the widget ID, see details here . int32_t get_id(); Set parent mother widget ID, see details here . ekg::ui::abstract *set_parent_id(int32_t parent_id); Get parent mother widget ID, see details here . int32_t get_parent_id(); Add a child to the widget , see details here . ekg::ui::abstract *add_child(int32_t id); Get the widget child id list, see details here . std::vector<int32_t> &get_child_id_list(); Remove a child widget from the mother widget , see details here . ekg::ui::abstract *remove_child(int32_t id); Check if the widget has a parent mother widget , see details here . bool has_parent(); Check if the widget has children, see details here . bool has_children(); Set widget alive state. ekg::ui::abstract *set_alive(bool state); Get widget alive state. bool is_alive(); Destroy the widget . void destroy(); Set the widget state . ekg::ui::abstract *set_state(const ekg::state &_state); Get the widget state . ekg::state get_state(); Set the widget type . ekg::ui::abstract *set_type(const ekg::type &_type); Get the widget type . ekg::type get_type(); Set the widget level . ekg::ui::abstract *set_level(const ekg::type &_level); Get the widget level . ekg::type get_level(); Get layout dock position. uint16_t get_place_dock(); Get the sync flags reference. uint16_t &get_sync(); Reset the UI data front-end with the widget back-end. void reset(); Access to absolute widget back-end rectangle. ekg::rect &widget(); Get the UI data front-end rectangle. ekg::rect &ui();","title":"Abstract"},{"location":"listbox/#container","text":"Each row is a component container, a listbox container allocates all Items cursively opened and dynamically calculates the visible index, based on the opened components count. When opening an item component, the container increases the open counter, and when an item component is closed, it decreases the open counter. This simple arithmetic system is useful for estimating container height. The rendering optimization is possible with a unique height, and by default, it is font normal size. Calculating a dynamically visible index requires normalizing the scroll value with the estimated height. scroll means the scrolling value, len is the container components' length, and height is the container's estimated height. The dynamic index calculation inverts the signal of the scroll because the scroll vector must subtract the position of the rectangle, and for the formula, it is not required, since we want to get normalized. All closed components are skipped in the rendering section, the item component contains the count of total children, and it is used to increase the current index iteration.","title":"Container"},{"location":"widget/","text":"Overview Abstract widget, and abstract UI data Type Level State Dimension Family Abstract widget, and abstract UI data EKG has two layers of objects: ekg::ui::abstract_widget , and ekg::ui::abstract . Both are used together but with different purposes. ekg::ui::abstract objects work as intermediary data between the user-programmer, and the ekg::ui::abstract_widget , which is used to process the logic and render. This philosophy allows more control, and memory security for the application. While backing service tools handle the ekg::ui::abstract_widget , the user can only access ekg::ui::abstract . Type Type represents different widgets, and helps check the instance of the current context widget object class. Type Widget ekg::type::abstract Abstract ekg::type::frame Frame ekg::type::label Label ekg::type::slider Slider ekg::type::slider2d Slider2D ekg::type::checkbox Checkbox ekg::type::textbox Textbox ekg::type::combobox Combobox ekg::type::listbox Listbox ekg::type::tab Tab ekg::type::popup Popup ekg::type::scroll Scroll Level A level-constant ekg::level::bottom_level , and ekg::level::top_level defines how the widget should be processed and placed. Most of the widgets except popup(s), by default sets ekg::level::bottom_level . Normal placement(s) ekg::level::bottom_level is followed by layout service , and can not interrupt the current processing widgets IO (input, events calling) context. Regular placement(s) ekg::level::top_level is followed by a private invocation of layout service features, and can interrupt the current processing widgets IO (input, events calling) context. Top-level widgets can not be a child, this rule allows separating IO events processing between top-level and bottom-level widgets. State Dimension The dimension of a widget contains differences between the horizontal and vertical axes. The width is based on pixels, and the height is based on a factor. The height factor is a multiple of font-size . If a widget height factor is 2, and the widget font setting is ekg::font::normal , then the size is 2*font_size . Family","title":"Widget"},{"location":"widget/#overview","text":"Abstract widget, and abstract UI data Type Level State Dimension Family","title":"Overview"},{"location":"widget/#abstract-widget-and-abstract-ui-data","text":"EKG has two layers of objects: ekg::ui::abstract_widget , and ekg::ui::abstract . Both are used together but with different purposes. ekg::ui::abstract objects work as intermediary data between the user-programmer, and the ekg::ui::abstract_widget , which is used to process the logic and render. This philosophy allows more control, and memory security for the application. While backing service tools handle the ekg::ui::abstract_widget , the user can only access ekg::ui::abstract .","title":"Abstract widget, and abstract UI data"},{"location":"widget/#type","text":"Type represents different widgets, and helps check the instance of the current context widget object class. Type Widget ekg::type::abstract Abstract ekg::type::frame Frame ekg::type::label Label ekg::type::slider Slider ekg::type::slider2d Slider2D ekg::type::checkbox Checkbox ekg::type::textbox Textbox ekg::type::combobox Combobox ekg::type::listbox Listbox ekg::type::tab Tab ekg::type::popup Popup ekg::type::scroll Scroll","title":"Type"},{"location":"widget/#level","text":"A level-constant ekg::level::bottom_level , and ekg::level::top_level defines how the widget should be processed and placed. Most of the widgets except popup(s), by default sets ekg::level::bottom_level . Normal placement(s) ekg::level::bottom_level is followed by layout service , and can not interrupt the current processing widgets IO (input, events calling) context. Regular placement(s) ekg::level::top_level is followed by a private invocation of layout service features, and can interrupt the current processing widgets IO (input, events calling) context. Top-level widgets can not be a child, this rule allows separating IO events processing between top-level and bottom-level widgets.","title":"Level"},{"location":"widget/#state","text":"","title":"State"},{"location":"widget/#dimension","text":"The dimension of a widget contains differences between the horizontal and vertical axes. The width is based on pixels, and the height is based on a factor. The height factor is a multiple of font-size . If a widget height factor is 2, and the widget font setting is ekg::font::normal , then the size is 2*font_size .","title":"Dimension"},{"location":"widget/#family","text":"","title":"Family"}]}