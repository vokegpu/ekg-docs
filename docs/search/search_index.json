{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"abstract/","text":"Overview Fundamentals Methods Fundamentals The abstract widget is not used for the user-programmer part and is not recommended for any purpose. Abstract widget is used by the runtime core as a polymorphism heritage base for handling everything. Methods Set tag for reserved purposes. ekg::ui::abstract *set_tag(std::string_view tag); Get the tag for reserved purposes. std::string_view get_tag(); Add a child to the widget. ekg::ui::abstract *add_child(int32_t id); Get the widget child id list. std::vector<int32_t> &get_child_id_list(); Remove a child widget from the mother widget. ekg::ui::abstract *remove_child(int32_t id); Set the widget ID. ekg::ui::abstract *set_id(int32_t id); Get the widget ID. int32_t get_id(); Set parent (mother) widget ID. ekg::ui::abstract *set_parent_id(int32_t parent_id); Get parent (mother) widget ID. int32_t get_parent_id(); Set the alive state of the widget. ekg::ui::abstract *set_alive(bool is_alive); Get the alive state. bool is_alive(); Destroy the widget. void destroy(); Set the state of the widget, visible invisible . ekg::ui::abstract *set_state(const ekg::state &_state); Get the state of the widget, visible invisible . ekg::state get_state(); Set the widget type . ekg::ui::abstract *set_type(const ekg::type &_type); Get the widget type . ekg::type get_type(); Get the place dock , fill next none right bottom . uint16_t get_place_dock(); Get the sync flags reference. uint16_t &get_sync(); Reset the UI data front-end with the widget back-end. void reset(); Access to absolute widget back-end rectangle. ekg::rect &widget(); Get the UI data front-end rectangle. ekg::rect &ui(); Set scaled height layout in font size (multiplied by). ekg::ui::abstract *set_scaled_height_layout(int32_t scaled_size); Check if the widget has a parent (mother widget). bool has_parent(); Check if the widget has children. bool has_children();","title":"Abstract"},{"location":"abstract/#overview","text":"Fundamentals Methods","title":"Overview"},{"location":"abstract/#fundamentals","text":"The abstract widget is not used for the user-programmer part and is not recommended for any purpose. Abstract widget is used by the runtime core as a polymorphism heritage base for handling everything.","title":"Fundamentals"},{"location":"abstract/#methods","text":"Set tag for reserved purposes. ekg::ui::abstract *set_tag(std::string_view tag); Get the tag for reserved purposes. std::string_view get_tag(); Add a child to the widget. ekg::ui::abstract *add_child(int32_t id); Get the widget child id list. std::vector<int32_t> &get_child_id_list(); Remove a child widget from the mother widget. ekg::ui::abstract *remove_child(int32_t id); Set the widget ID. ekg::ui::abstract *set_id(int32_t id); Get the widget ID. int32_t get_id(); Set parent (mother) widget ID. ekg::ui::abstract *set_parent_id(int32_t parent_id); Get parent (mother) widget ID. int32_t get_parent_id(); Set the alive state of the widget. ekg::ui::abstract *set_alive(bool is_alive); Get the alive state. bool is_alive(); Destroy the widget. void destroy(); Set the state of the widget, visible invisible . ekg::ui::abstract *set_state(const ekg::state &_state); Get the state of the widget, visible invisible . ekg::state get_state(); Set the widget type . ekg::ui::abstract *set_type(const ekg::type &_type); Get the widget type . ekg::type get_type(); Get the place dock , fill next none right bottom . uint16_t get_place_dock(); Get the sync flags reference. uint16_t &get_sync(); Reset the UI data front-end with the widget back-end. void reset(); Access to absolute widget back-end rectangle. ekg::rect &widget(); Get the UI data front-end rectangle. ekg::rect &ui(); Set scaled height layout in font size (multiplied by). ekg::ui::abstract *set_scaled_height_layout(int32_t scaled_size); Check if the widget has a parent (mother widget). bool has_parent(); Check if the widget has children. bool has_children();","title":"Methods"},{"location":"button/","text":"Overview Fundamentals Examples Methods Fundamentals The button widget works fundamentally simply, you have a text, and the alignment of text. Each button has it is own optional ekg::cpu::event callback event task , where you can add one lambda function. The button widget contains two string sets set_text and set_tag , set_tag is reserved for user purposes, while set_text is the visible text of the widget button. Examples For creating a simple button with no callback event. auto p_button = ekg::button(\"cat\", ekg::dock::fill | ekg::next); The first parameter is the visible text of a button. The second parameter is the docking alignment in the frame widget. To create a callback button, with tasks . p_button->set_callback(new ekg::cpu::event(\"cat\", nullptr, [](void *p_callback) { ekg::log() << \"Cat!\"; })); This callback event is not deleted after execution, because it is batched, which means that all clicks will execute this task . Methods Button Set the font size of button text, ekg::font::small ekg::font::normal ekg::font::big . ekg::ui::button *set_font_size(ekg::font font); Get the font size of button text, ekg::font::small ekg::font::normal ekg::font::big . ekg::font get_font_size(); Set dock place, fill next none right bottom . ekg::ui::button *set_place(uint16_t dock); Set dimension width in pixels. ekg::ui::button *set_width(float w); Get dimension width in pixels. float get_width(); Set dimension height in font size scale (multiplied by). ekg::ui::button *set_scaled_height(int32_t h); Get dimension height in font size scale (multiplied by). int32_t get_scaled_height(); Get dimension height in pixels. float get_height(); Set callback event task . ekg::ui::button *set_callback(ekg::cpu::event *p_callback); Get callback event task . ekg::cpu::event *get_callback(); Set display text. ekg::ui::button *set_text(std::string_view text); Get display text. std::string_view get_text(); Set button state pressed/callback. ekg::ui::button *set_value(bool state); Get button state. bool get_value(); Set text alignment dock, center left right top bottom . ekg::ui::button *set_text_align(uint16_t dock); Get text alignment dock. uint16_t get_text_align(); Abstract Set tag for reserved purposes. ekg::ui::abstract *set_tag(std::string_view tag); Get the tag for reserved purposes. std::string_view get_tag(); Add a child to the widget. ekg::ui::abstract *add_child(int32_t id); Get the widget child id list. std::vector<int32_t> &get_child_id_list(); Remove a child widget from the mother widget. ekg::ui::abstract *remove_child(int32_t id); Set the widget ID. ekg::ui::abstract *set_id(int32_t id); Get the widget ID. int32_t get_id(); Set parent (mother) widget ID. ekg::ui::abstract *set_parent_id(int32_t parent_id); Get parent (mother) widget ID. int32_t get_parent_id(); Set the alive state of the widget. ekg::ui::abstract *set_alive(bool is_alive); Get the alive state. bool is_alive(); Destroy the widget. void destroy(); Set the state of the widget, visible invisible . ekg::ui::abstract *set_state(const ekg::state &_state); Get the state of the widget, visible invisible . ekg::state get_state(); Set the widget type . ekg::ui::abstract *set_type(const ekg::type &_type); Get the widget type . ekg::type get_type(); Get the place dock , fill next none right bottom . uint16_t get_place_dock(); Get the sync flags reference. uint16_t &get_sync(); Reset the UI data front-end with the widget back-end. void reset(); Access to absolute widget back-end rectangle. ekg::rect &widget(); Get the UI data front-end rectangle. ekg::rect &ui(); Set scaled height layout in font size (multiplied by). ekg::ui::abstract *set_scaled_height_layout(int32_t scaled_size); Check if the widget has a parent (mother widget). bool has_parent(); Check if the widget has children. bool has_children();","title":"Overview"},{"location":"button/#overview","text":"Fundamentals Examples Methods","title":"Overview"},{"location":"button/#fundamentals","text":"The button widget works fundamentally simply, you have a text, and the alignment of text. Each button has it is own optional ekg::cpu::event callback event task , where you can add one lambda function. The button widget contains two string sets set_text and set_tag , set_tag is reserved for user purposes, while set_text is the visible text of the widget button.","title":"Fundamentals"},{"location":"button/#examples","text":"For creating a simple button with no callback event. auto p_button = ekg::button(\"cat\", ekg::dock::fill | ekg::next); The first parameter is the visible text of a button. The second parameter is the docking alignment in the frame widget. To create a callback button, with tasks . p_button->set_callback(new ekg::cpu::event(\"cat\", nullptr, [](void *p_callback) { ekg::log() << \"Cat!\"; })); This callback event is not deleted after execution, because it is batched, which means that all clicks will execute this task .","title":"Examples"},{"location":"button/#methods","text":"","title":"Methods"},{"location":"button/#button","text":"Set the font size of button text, ekg::font::small ekg::font::normal ekg::font::big . ekg::ui::button *set_font_size(ekg::font font); Get the font size of button text, ekg::font::small ekg::font::normal ekg::font::big . ekg::font get_font_size(); Set dock place, fill next none right bottom . ekg::ui::button *set_place(uint16_t dock); Set dimension width in pixels. ekg::ui::button *set_width(float w); Get dimension width in pixels. float get_width(); Set dimension height in font size scale (multiplied by). ekg::ui::button *set_scaled_height(int32_t h); Get dimension height in font size scale (multiplied by). int32_t get_scaled_height(); Get dimension height in pixels. float get_height(); Set callback event task . ekg::ui::button *set_callback(ekg::cpu::event *p_callback); Get callback event task . ekg::cpu::event *get_callback(); Set display text. ekg::ui::button *set_text(std::string_view text); Get display text. std::string_view get_text(); Set button state pressed/callback. ekg::ui::button *set_value(bool state); Get button state. bool get_value(); Set text alignment dock, center left right top bottom . ekg::ui::button *set_text_align(uint16_t dock); Get text alignment dock. uint16_t get_text_align();","title":"Button"},{"location":"button/#abstract","text":"Set tag for reserved purposes. ekg::ui::abstract *set_tag(std::string_view tag); Get the tag for reserved purposes. std::string_view get_tag(); Add a child to the widget. ekg::ui::abstract *add_child(int32_t id); Get the widget child id list. std::vector<int32_t> &get_child_id_list(); Remove a child widget from the mother widget. ekg::ui::abstract *remove_child(int32_t id); Set the widget ID. ekg::ui::abstract *set_id(int32_t id); Get the widget ID. int32_t get_id(); Set parent (mother) widget ID. ekg::ui::abstract *set_parent_id(int32_t parent_id); Get parent (mother) widget ID. int32_t get_parent_id(); Set the alive state of the widget. ekg::ui::abstract *set_alive(bool is_alive); Get the alive state. bool is_alive(); Destroy the widget. void destroy(); Set the state of the widget, visible invisible . ekg::ui::abstract *set_state(const ekg::state &_state); Get the state of the widget, visible invisible . ekg::state get_state(); Set the widget type . ekg::ui::abstract *set_type(const ekg::type &_type); Get the widget type . ekg::type get_type(); Get the place dock , fill next none right bottom . uint16_t get_place_dock(); Get the sync flags reference. uint16_t &get_sync(); Reset the UI data front-end with the widget back-end. void reset(); Access to absolute widget back-end rectangle. ekg::rect &widget(); Get the UI data front-end rectangle. ekg::rect &ui(); Set scaled height layout in font size (multiplied by). ekg::ui::abstract *set_scaled_height_layout(int32_t scaled_size); Check if the widget has a parent (mother widget). bool has_parent(); Check if the widget has children. bool has_children();","title":"Abstract"},{"location":"checkbox/","text":"Overview Fundamentals Examples Methods Fundamentals","title":"Overview"},{"location":"checkbox/#overview","text":"Fundamentals Examples Methods","title":"Overview"},{"location":"checkbox/#fundamentals","text":"","title":"Fundamentals"},{"location":"home/","text":"EKG WIKI HOME Welcome to the EKG wiki! UI Widget Abstract Button Checkbox Listbox Services & Features Layout Input Handler Allocator GPU Tools Core IO Events Task Utility Item","title":"Home"},{"location":"home/#ekg-wiki-home","text":"Welcome to the EKG wiki!","title":"EKG WIKI HOME"},{"location":"home/#ui","text":"Widget Abstract Button Checkbox Listbox","title":"UI"},{"location":"home/#services-features","text":"Layout Input Handler Allocator GPU Tools","title":"Services &amp; Features"},{"location":"home/#core","text":"IO Events Task","title":"Core"},{"location":"home/#utility","text":"Item","title":"Utility"},{"location":"item/","text":"Overview Fundamentals Examples Methods Fundamentals The EKG library contains an item collector named ekg::item , the item is a recursive vector collection. Examples The item contains the following fields: value display-text/tag of item. attr the attribute flag defines the rendering, and processing behavior. child_list child list to other items. component geometry data of item component. Setting a value to an item is simple: ekg::item item(\"animals\"); // constructor explicit ekg::item item {\"animals\"}; // initialization-list implicit ekg::item item = {\"animals\"}; // assign initialization-list implicit ekg::item item {}; // initialization-list implicit item.value = \"animals\"; // accessing the field, but is not too recommendedd Item contains attr (attributes) flags and state flags, both manually configurable or automatically by setting the value component with special chars. Special chars: \\t add automatically the attribute ekg::attr::separator . \\\\ add automatically the attribute ekg::attr::box . \\1 add automatically the attribute ekg::attr::category . \\2 add automatically the attribute ekg::attr::row . \\3 add automatically the attribute ekg::attr::row_member . \\4 add automatically the attribute ekg::attr::unselectable . ekg::item item {\"Animals\"}; item.set_value(\"\\t\\\\Select All\"); // insert a std::vector<std::string> to item. item.insert({\"\\\\Dogs\"}); item.insert({\"\\\\Cats\"}); item.insert({\"\\\\Humans\"}); You can iterate over the item children using for loop: ekg::item item(\"animals\"); item.insert({\"dogs\", \"cats\", \"humans\"}); for (ekg::item &items : item) { std::cout << items.value << std::endl; } Methods Set value with attributes check, use this instead of setting directly the field. void set_value(std::string_view _value); Initialize an item child without generating a copy. ekg::item &emplace_back(); Insert an item copy in the child list. void push_back(const ekg::item &item); Insert an item by setting the value. void push_back(std::string_view item_value); Insert a std::vector<ekg::item> child list. void insert(const std::vector<std::string> &item_value_list); Get the child item by index position. ekg::item &at(uint64_t index); Check if has item children. bool empty() const; Get the size of the child list. uint64_t size() const; Get begin iterator point. std::vector<ekg::item>::iterator begin(); Get end iterator point. std::vector<ekg::item>::iterator end(); Get const begin iterator point. std::vector<ekg::item>::const_iterator cbegin() const; Get const end iterator point. std::vector<ekg::item>::const_iterator cend() const;","title":"Overview"},{"location":"item/#overview","text":"Fundamentals Examples Methods","title":"Overview"},{"location":"item/#fundamentals","text":"The EKG library contains an item collector named ekg::item , the item is a recursive vector collection.","title":"Fundamentals"},{"location":"item/#examples","text":"The item contains the following fields: value display-text/tag of item. attr the attribute flag defines the rendering, and processing behavior. child_list child list to other items. component geometry data of item component. Setting a value to an item is simple: ekg::item item(\"animals\"); // constructor explicit ekg::item item {\"animals\"}; // initialization-list implicit ekg::item item = {\"animals\"}; // assign initialization-list implicit ekg::item item {}; // initialization-list implicit item.value = \"animals\"; // accessing the field, but is not too recommendedd Item contains attr (attributes) flags and state flags, both manually configurable or automatically by setting the value component with special chars. Special chars: \\t add automatically the attribute ekg::attr::separator . \\\\ add automatically the attribute ekg::attr::box . \\1 add automatically the attribute ekg::attr::category . \\2 add automatically the attribute ekg::attr::row . \\3 add automatically the attribute ekg::attr::row_member . \\4 add automatically the attribute ekg::attr::unselectable . ekg::item item {\"Animals\"}; item.set_value(\"\\t\\\\Select All\"); // insert a std::vector<std::string> to item. item.insert({\"\\\\Dogs\"}); item.insert({\"\\\\Cats\"}); item.insert({\"\\\\Humans\"}); You can iterate over the item children using for loop: ekg::item item(\"animals\"); item.insert({\"dogs\", \"cats\", \"humans\"}); for (ekg::item &items : item) { std::cout << items.value << std::endl; }","title":"Examples"},{"location":"item/#methods","text":"Set value with attributes check, use this instead of setting directly the field. void set_value(std::string_view _value); Initialize an item child without generating a copy. ekg::item &emplace_back(); Insert an item copy in the child list. void push_back(const ekg::item &item); Insert an item by setting the value. void push_back(std::string_view item_value); Insert a std::vector<ekg::item> child list. void insert(const std::vector<std::string> &item_value_list); Get the child item by index position. ekg::item &at(uint64_t index); Check if has item children. bool empty() const; Get the size of the child list. uint64_t size() const; Get begin iterator point. std::vector<ekg::item>::iterator begin(); Get end iterator point. std::vector<ekg::item>::iterator end(); Get const begin iterator point. std::vector<ekg::item>::const_iterator cbegin() const; Get const end iterator point. std::vector<ekg::item>::const_iterator cend() const;","title":"Methods"},{"location":"layout/","text":"Overview Here you will read these main topics: Fundamentals Docking Widgets Fundamentals The layout mask or docking system, is an internal feature of the layout service, A layout mask is a mask of positions between rectangles of a widget. The purpose of having a layout mask is to make flexible widgets. Docking The acceptable docking positions are: center, left, right, top, bottom Each docking direction has it is own behavior. Widgets All widgets use the layout mask feature, normally you can set set_*_align . e.g. button widget align method: p_button->set_text_align(ekg::dock::center);","title":"Overview"},{"location":"layout/#overview","text":"Here you will read these main topics: Fundamentals Docking Widgets","title":"Overview"},{"location":"layout/#fundamentals","text":"The layout mask or docking system, is an internal feature of the layout service, A layout mask is a mask of positions between rectangles of a widget. The purpose of having a layout mask is to make flexible widgets.","title":"Fundamentals"},{"location":"layout/#docking","text":"The acceptable docking positions are: center, left, right, top, bottom Each docking direction has it is own behavior.","title":"Docking"},{"location":"layout/#widgets","text":"All widgets use the layout mask feature, normally you can set set_*_align . e.g. button widget align method: p_button->set_text_align(ekg::dock::center);","title":"Widgets"},{"location":"task/","text":"Overview Runtime Execution Runtime The event system and handler service exist for two different purposes, the handler is a task manager that works with callback events (tasks) and executes the main tasks of the EKG runtime core. The event system exists to release UI events. Execution The structure of a task is simple. ekg::cpu::event task { .p_tag = \"task event cat 1\", .p_callback = nullptr, .function = [](void *p_callback) {}; }; For dispatching a task is simple, reference or copy ekg::core->service_handler.generate() auto &task = ekg::core->service_handler.generate(); task.p_tag = \"cat\"; task.p_callback = nullptr; task.function = [](void *p_callback) {}; // It is already dispatched :)!","title":"Overview"},{"location":"task/#overview","text":"Runtime Execution","title":"Overview"},{"location":"task/#runtime","text":"The event system and handler service exist for two different purposes, the handler is a task manager that works with callback events (tasks) and executes the main tasks of the EKG runtime core. The event system exists to release UI events.","title":"Runtime"},{"location":"task/#execution","text":"The structure of a task is simple. ekg::cpu::event task { .p_tag = \"task event cat 1\", .p_callback = nullptr, .function = [](void *p_callback) {}; }; For dispatching a task is simple, reference or copy ekg::core->service_handler.generate() auto &task = ekg::core->service_handler.generate(); task.p_tag = \"cat\"; task.p_callback = nullptr; task.function = [](void *p_callback) {}; // It is already dispatched :)!","title":"Execution"},{"location":"widget/","text":"Overview Abstract widget, and abstract UI data Type Level Abstract widget, and abstract UI data EKG has two layers of objects: ekg::ui::abstract_widget , and ekg::ui::abstract . Both are used together but with different purposes. ekg::ui::abstract objects work as intermediary data between the user-programmer, and the ekg::ui::abstract_widget , which is used for processing the logic, and rendering. This philosophy allows more control, and memory security for the application. While backing service tools handle the ekg::ui::abstract_widget , the user only has access to ekg::ui::abstract . Type Type represents different widgets, and helps check the instance of the current context widget object class, ekg::type contains the following enum(s) constant: ekg::type::abstract refers to the abstract UI element ekg::type::frame refers to the frame UI element ekg::type::button refers to the button UI element ekg::type::label refers to the label UI element ekg::type::slider refers to the slider UI element ekg::type::slider2d refers to the slider 2D UI element ekg::type::checkbox refers to the frame UI element ekg::type::textbox refers to the textbox UI element ekg::type::combobox refers to the combobox UI element ekg::type::listbox refers to the listbox UI element ekg::type::tab refers to the tab UI element ekg::type::popup refers to the popup UI element ekg::type::scroll refers to the scroll UI element Level A level-constant ekg::level::bottom_level , and ekg::level::top_level defines how the widget should be processed and placed. Most of the widgets except popup(s), by default sets ekg::level::bottom_level . Normal placement(s) ekg::level::bottom_level is followed by layout service , and can not interrupt the current processing widgets IO (input, events calling) context. Regular placement(s) ekg::level::top_level is followed by a private invocation of layout service features, and has the ability to interrupt the current processing widgets IO (input, events calling) context. Top-level widgets can not be a child, this rule allows separating IO events processing between top-level and bottom-level widgets.","title":"Overview"},{"location":"widget/#overview","text":"Abstract widget, and abstract UI data Type Level","title":"Overview"},{"location":"widget/#abstract-widget-and-abstract-ui-data","text":"EKG has two layers of objects: ekg::ui::abstract_widget , and ekg::ui::abstract . Both are used together but with different purposes. ekg::ui::abstract objects work as intermediary data between the user-programmer, and the ekg::ui::abstract_widget , which is used for processing the logic, and rendering. This philosophy allows more control, and memory security for the application. While backing service tools handle the ekg::ui::abstract_widget , the user only has access to ekg::ui::abstract .","title":"Abstract widget, and abstract UI data"},{"location":"widget/#type","text":"Type represents different widgets, and helps check the instance of the current context widget object class, ekg::type contains the following enum(s) constant: ekg::type::abstract refers to the abstract UI element ekg::type::frame refers to the frame UI element ekg::type::button refers to the button UI element ekg::type::label refers to the label UI element ekg::type::slider refers to the slider UI element ekg::type::slider2d refers to the slider 2D UI element ekg::type::checkbox refers to the frame UI element ekg::type::textbox refers to the textbox UI element ekg::type::combobox refers to the combobox UI element ekg::type::listbox refers to the listbox UI element ekg::type::tab refers to the tab UI element ekg::type::popup refers to the popup UI element ekg::type::scroll refers to the scroll UI element","title":"Type"},{"location":"widget/#level","text":"A level-constant ekg::level::bottom_level , and ekg::level::top_level defines how the widget should be processed and placed. Most of the widgets except popup(s), by default sets ekg::level::bottom_level . Normal placement(s) ekg::level::bottom_level is followed by layout service , and can not interrupt the current processing widgets IO (input, events calling) context. Regular placement(s) ekg::level::top_level is followed by a private invocation of layout service features, and has the ability to interrupt the current processing widgets IO (input, events calling) context. Top-level widgets can not be a child, this rule allows separating IO events processing between top-level and bottom-level widgets.","title":"Level"}]}